<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ripple-Carry Adder - Logic for Systems: Lightweight Formal Methods for Everybody</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../.././custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../welcome.html">How to Read this book</a></li><li class="chapter-item affix "><li class="part-title">Preamble: Beyond Testing</li><li class="chapter-item "><a href="../../chapters/manifesto/job.html">What good is this book?</a></li><li class="chapter-item "><a href="../../chapters/manifesto/manifesto.html">Logic for Systems</a></li><li class="chapter-item "><a href="../../chapters/properties/pbt.html">From Tests to Properties</a></li><li class="chapter-item affix "><li class="part-title">Modeling Static Scenarios</li><li class="chapter-item "><a href="../../chapters/ttt/ttt.html">Tic-Tac-Toe</a></li><li class="chapter-item "><a href="../../chapters/bst/bst.html">Binary Search Trees</a></li><li class="chapter-item expanded "><a href="../../chapters/adder/rca.html" class="active">Ripple-Carry Adder</a></li><li class="chapter-item "><a href="../../chapters/qna/static.html">Q&A: Static Modeling</a></li><li class="chapter-item affix "><li class="part-title">Discrete Event Systems</li><li class="chapter-item "><a href="../../chapters/ttt/ttt_games.html">Transitions, Traces, and Verification</a></li><li class="chapter-item "><a href="../../chapters/inductive/bsearch.html">Counterexamples to Induction</a></li><li class="chapter-item "><a href="../../chapters/bst/descent.html">BSTs: Recursive Descent</a></li><li class="chapter-item "><a href="../../chapters/validation/validating_events.html">Validating Models (in progress)</a></li><li class="chapter-item "><a href="../../chapters/qna/events.html">Q&A: Event Systems (in progress)</a></li><li class="chapter-item affix "><li class="part-title">Modeling Relationships</li><li class="chapter-item "><a href="../../chapters/relations/modeling-booleans-1.html">Relational Forge, Modeling Logic</a></li><li class="chapter-item "><a href="../../chapters/relations/reachability.html">Transitive Closure</a></li><li class="chapter-item "><a href="../../chapters/relations/sets-induction-mutex.html">Modeling Mutual Exclusion</a></li><li class="chapter-item "><a href="../../chapters/relations/sets-beyond-assertions.html">Going Beyond Assertions</a></li><li class="chapter-item "><a href="../../chapters/solvers/bounds_booleans_how_forge_works.html">How does Forge Work?</a></li><li class="chapter-item "><a href="../../chapters/qna/relations.html">Q&A: Relations</a></li><li class="chapter-item affix "><li class="part-title">Temporal Specification</li><li class="chapter-item "><a href="../../chapters/temporal/liveness_and_lassos.html">Liveness and Lassos</a></li><li class="chapter-item "><a href="../../chapters/temporal/temporal_operators.html">Temporal Forge</a></li><li class="chapter-item "><a href="../../chapters/temporal/temporal_operators_2.html">Linear Temporal Logic</a></li><li class="chapter-item "><a href="../../chapters/temporal/obligations_past.html">Obligations and the Past</a></li><li class="chapter-item "><a href="../../chapters/temporal/fixing_lock_temporal.html">Mutual Exclusion, Revisited</a></li><li class="chapter-item affix "><li class="part-title">Additional Examples, Case Studies, and Further Reading</li><li class="chapter-item "><a href="../../chapters/raft/raft.html">Modeling Raft in Anger (in progress)</a></li><li class="chapter-item "><div>Forge: Comparing Prim's and Dijkstra's Algorithms (in progress)</div></li><li class="chapter-item "><div>Forge+Industry: Policy and Network Analysis (in progress; DEMO: ABAC, Margrave, Zelkova)</div></li><li class="chapter-item "><div>Forge+Industry: Crypto Protocol Analysis (in progress; DEMO: crypto lang, CPSA or other)</div></li><li class="chapter-item "><div>Program Synthesis (in progress; DEMO: SSA synth, Sygus)</div></li><li class="chapter-item "><a href="../../further_reading.html">Further Reading (in progress)</a></li><li class="chapter-item affix "><li class="part-title">Construction Storage</li><li class="chapter-item "><a href="../../chapters/solvers/dpll.html">DPLL (to edit)</a></li><li class="chapter-item "><a href="../../chapters/solvers/resolution.html">Propositional resolution (to edit)</a></li><li class="chapter-item affix "><li class="part-title">Forge Documentation</li><li class="chapter-item "><a href="../../chapters/docs/test.html">Forge Version</a></li><li class="chapter-item "><a href="../../docs/getting-started/installation.html">Installation</a></li><li class="chapter-item "><a href="../../docs/building-models/overview.html">Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/building-models/alloy-user-overview.html">Addendum for Alloy Users</a></li></ol></li><li class="chapter-item "><a href="../../docs/building-models/sigs/sigs.html">Sigs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/building-models/sigs/inheritance.html">Inheritance</a></li><li class="chapter-item "><a href="../../docs/building-models/sigs/singleton-maybe-sigs.html">Singleton, Maybe, and Abstract Sigs</a></li><li class="chapter-item "><a href="../../docs/building-models/sigs/multiplicity.html">Field Multiplicity</a></li><li class="chapter-item "><a href="../../docs/building-models/sigs/advanced.html">Advanced: Sigs and fields, under-the-hood</a></li></ol></li><li class="chapter-item "><a href="../../docs/building-models/constraints/constraints.html">Constraints</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/building-models/constraints/instances.html">Instances</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/formulas/formulas.html">Formulas</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/building-models/constraints/formulas/operators.html">Operators</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/formulas/cardinality-membership.html">Cardinality and Membership</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/formulas/quantifiers.html">Quantifiers</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/formulas/predicates.html">Predicates</a></li></ol></li><li class="chapter-item "><a href="../../docs/building-models/constraints/expressions/expressions.html">Expressions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/building-models/constraints/expressions/relational-expressions/relational-expressions.html">Relational Operators</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/expressions/functions.html">Functions</a></li><li class="chapter-item "><a href="../../docs/building-models/constraints/expressions/let-expressions.html">Let-Expressions</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../docs/building-models/comments.html">Comments</a></li><li class="chapter-item "><a href="../../docs/running-models/running.html">Running</a></li><li class="chapter-item "><a href="../../docs/running-models/sterling-visualizer.html">Sterling Visualizer</a></li><li class="chapter-item "><a href="../../docs/running-models/bounds.html">Bounds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/running-models/concrete-instance-bounds.html">Concrete Instance Bounds</a></li></ol></li><li class="chapter-item "><a href="../../docs/running-models/options.html">Options</a></li><li class="chapter-item "><a href="../../docs/testing-chapter/testing.html">Testing</a></li><li class="chapter-item "><a href="../../docs/forge-standard-library/integers.html">Integers</a></li><li class="chapter-item "><a href="../../docs/forge-standard-library/constants-and-keywords.html">Constants and Keywords</a></li><li class="chapter-item "><a href="../../docs/forge-standard-library/helpers.html">Helpers: Sequences and Reachability</a></li><li class="chapter-item "><a href="../../docs/electrum/electrum-overview.html">Temporal Forge Overview and Operators</a></li><li class="chapter-item "><a href="../../docs/sterling/custom-basics.html">Custom Visualization Basics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docs/sterling/d3fx_apr23.html">D3FX Helpers (April 2023)</a></li><li class="chapter-item "><a href="../../docs/sterling/svg-tips.html">Working with SVG and Imports</a></li></ol></li><li class="chapter-item "><a href="../../docs/dsl/abac.html">Attribute-Based Access Control</a></li><li class="chapter-item "><a href="../../docs/glossary.html">What should I do if...</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Logic for Systems: Lightweight Formal Methods for Everybody</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ripple-carry-adder"><a class="header" href="#ripple-carry-adder">Ripple-Carry Adder</a></h1>
<p>Let's model a third system in Froglet. We'll focus on something even more concrete, something that is implemented in <em>hardware</em>: a circuit for adding together two numbers called a <em>ripple-carry adder</em> (RCA). Along the way, even though the adder doesn't &quot;change&quot;, we'll still learn a useful technique for modeling systems that change over time. </p>
<p>To understand an RCA, let's first think about adding together a pair of one-bit numbers. We might draw a table with four rows to represent this:</p>
<div class="table-wrapper"><table><thead><tr><th>Input Bit A</th><th>Input Bit B</th><th>Result Bit</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>2</td></tr>
</tbody></table>
</div>
<p>But, wait a moment. If we're building this into a circuit, and these inputs and outputs are single bits, we can't return <code>2</code> as the result. Similarly to how we might manually add <code>12345</code> and <code>67890</code> on paper, carrying a <code>1</code> in a few places...</p>
<center><img width="50%" src="./Addition.png" style="background-color:white"/></center>
<p>Notice how, on paper, we sweep from right to left. That is, we handle the least-significant digits first. </p>
<p><strong>Exercise:</strong> Why is that? (Your first answer may be: &quot;Because that's how you do it.&quot; But hold yourself to a higher standard. Was there a good reason to start on the right, and move left, rather than the other way around?)</p>
<details>
<summary>Think, then click!</summary>
<p>Carrying! If we started to the left, we'd give answers for those digits prematurely. (To see this, try doing the above arithmetic by hand again, but starting on the left and moving right. You'll need to carry, as before, but it will be <em>too late!</em>)</p>
</details>
<hr />
<p>We need to carry a bit with value <code>1</code> in the <code>2s</code> place.</p>
<div class="table-wrapper"><table><thead><tr><th>Input Bit A</th><th>Input Bit B</th><th>Result Bit</th><th>Carry Bit (double value!)</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>Suppose we've built a circuit like the above; this is called a <em>full adder</em> (FullAdder).</p>
<div id="admonition-building-circuits" class="admonition admonish-note">
<div class="admonition-title">
<p>Building circuits</p>
<p><a class="admonition-anchor-link" href="#admonition-building-circuits"></a></p>
</div>
<div>
<p>Exactly how we build that circuit is outside the scope of this example. Generally, we build them with logic gates: tiny devices that implement boolean operators like &quot;and&quot;, &quot;not&quot;, etc.</p>
</div>
</div>
<p>Now the question is: how do we build an adder that can handle numbers of the sizes that real computers use: 8-bit, 32-bit, or even 64-bit values? The answer is that we'll chain together multiple adder circuits like the above, letting the carry bits &quot;ripple&quot; forward as an extra, 3rd input to all the adders except the first one. E.g., if we were adding together a pair of 4-bit numbers—4 and 5, say—we'd chain together 4 adders like so:</p>
<center><img width="70%" src="./rca.svg" style="background-color:white"/></center>
<p>Notice that each full adder accepts <em>3</em> input bits, just like in the above table: </p>
<ul>
<li>a bit from the first number;</li>
<li>a bit from the second number; and</li>
<li>a carry bit.</li>
</ul>
<p>Each full adder has <em>2</em> output bits:</p>
<ul>
<li>the value at this bit (1s place, 2s place, etc.); and </li>
<li>the carry bit, if applicable.</li>
</ul>
<p>Our task here is to model this circuit in Forge, and confirm that it actually works correctly. </p>
<div id="admonition-circuits-arent-easy" class="admonition admonish-note">
<div class="admonition-title">
<p>Circuits aren't easy</p>
<p><a class="admonition-anchor-link" href="#admonition-circuits-arent-easy"></a></p>
</div>
<div>
<p>This might look &quot;obvious&quot;, but there are things that can go wrong even at this level. </p>
<p>If you've studied physics or electrical engineering, you might also see that this model won't match reality: it takes <em>time</em> for the signals to propagate between adders, and this delay can cause serious problems if the chain of adders is too long. We'll address that with a new, more sophisticated model, later.</p>
</div>
</div>
<h2 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h2>
<p>We'll start by defining a data type—<code>Digit</code>—for the wire values, which can be either <code>T</code> or <code>F</code> (short for &quot;true&quot; and &quot;false&quot;; you can also think of these as representing &quot;1&quot; and &quot;0&quot; or &quot;high&quot; and &quot;low&quot;).</p>
<pre><code class="language-forge editable">abstract sig Digit {}
one sig T, F extends Digit {}
</code></pre>
<p>Then we'll define a <code>sig</code> for full adders, which will be chained together to form the ripple-carry adder. We'll give each full adder fields representing its input bits and output bits:</p>
<pre><code class="language-forge editable">sig FullAdder { 
  -- input value bits 
  a_in, b_in: one Digit,  
  -- input carry bit
  carry_in: one Digit,
  -- output (sum) value
  sum_out: one Digit,
  -- output carry bit 
  carry_out: one Digit
}
</code></pre>
<div id="admonition-digit-is-not-the-same-as-boolean" class="admonition admonish-warning">
<div class="admonition-title">
<p><code>Digit</code> is not the same as boolean!</p>
<p><a class="admonition-anchor-link" href="#admonition-digit-is-not-the-same-as-boolean"></a></p>
</div>
<div>
<p>Beware confusing the <code>Digit</code> sig we created, and the <code>T</code> and <code>F</code> values in it, with the result of evaluating Forge constraints. Forge doesn't &quot;know&quot; anything special about <code>T</code> or <code>F</code>; <code>Digit</code> is just another datatype. <strong>If we write something like <code>(some FullAdder) = T</code>, Forge will give an error message.</strong> This is because, to Forge, <code>T</code> is just another value we defined in the model. Instead, we write just <code>(some FullAdder)</code> to say &quot;there is some full adder in the instance&quot;. </p>
<p>This will come up again as we continue to develop the model.</p>
</div>
</div>
<p>Finally, we'll define the ripple-carry adder chain:</p>
<pre><code class="language-forge editable">one sig RCA {
  -- the first full adder in the chain
  firstAdder: one FullAdder,
  -- the next full adder in the chain (if any)
  nextAdder: pfunc FullAdder -&gt; FullAdder
}
</code></pre>
<div id="admonition-reminder" class="admonition admonish-note">
<div class="admonition-title">
<p>Reminder</p>
<p><a class="admonition-anchor-link" href="#admonition-reminder"></a></p>
</div>
<div>
<p>Recall that a <code>pfunc</code> field is a partial function, sort of like a dictionary: every input is mapped to at most one output.</p>
</div>
</div>
<p>Notice that there is only ever one ripple-carry adder in an instance, and that it has fields that define which full adder comes first (i.e., operates on the <code>1</code>s place), and what the succession is. We will probably need to enforce what these mean once we start defining wellformedness. </p>
<h2 id="wellformedness"><a class="header" href="#wellformedness">Wellformedness</a></h2>
<p>What do we need to encode in a <code>wellformed</code> predicate? Right now, it seems that nothing has told Forge that <code>firstAdder</code> should really <em>be</em> the first adder, nor that <code>nextAdder</code> defines a linear path through all the full adders. So we should probably start with those two facts. </p>
<pre><code class="language-forge editable">pred wellformed {
  -- The RCA's firstAdder is &quot;upstream&quot; from all other FullAdders
  all fa: FullAdder | (fa != RCA.firstAdder) implies reachable[fa, RCA.firstAdder, RCA.nextAdder]
  -- there are no cycles in the nextAdder function.
  all fa: FullAdder | not reachable[fa, fa, RCA.nextAdder]  
}
</code></pre>
<p>Notice that we've used <code>implies</code> to limit the power of the <code>all</code> quantifier: it doesn't impose the reachability condition on <em>all</em> <code>FullAdder</code>s, but rather than all of them except for <code>RCA.firstAdder</code>. This is a common pattern when you want to assert something is true, but only contingently. </p>
<div id="admonition-case-sensitivity-and-variable-names" class="admonition admonish-tip">
<div class="admonition-title">
<p>Case sensitivity and variable names</p>
<p><a class="admonition-anchor-link" href="#admonition-case-sensitivity-and-variable-names"></a></p>
</div>
<div>
<p>In our model so far, <code>FullAdder</code> is the name of a datatype. When writing the constraints above, I said: &quot;for every full adder...&quot; and named this arbitrary adder <code>fa</code>. These two, <code>FullAdder</code> and <code>fa</code> are different. For a start, <code>FullAdder</code> is defined within the entire model, but <code>fa</code> is only defined within the scope of the <code>all</code> quantifier.</p>
</div>
</div>
<p>We've used the <code>reachable</code> helper before, but it's worth mentioning again: <code>A</code> is reachable from <code>B</code> via <em>one or more applications</em> of <code>f</code> if and only if <code>reachable[A, B, f]</code> is true. That &quot;one or more applications&quot; is important, and is why we needed to add the <code>(fa != RCA.firstAdder) implies</code> portion of the first constraint: <code>RCA.firstAdder</code> shouldn't be the successor of any full adder, and if it were its own successor, that would be a cycle in the line of adders. If we had left out the implication, and written just <code>all fa: FullAdder | reachable[fa, RCA.firstAdder, RCA.nextAdder]</code>, <code>RCA.firstAdder</code> would need to have a predecessor, which would contradict the second constraint.</p>
<h2 id="more-predicates"><a class="header" href="#more-predicates">More Predicates</a></h2>
<p>Before we write some examples for <code>wellformed</code>, let's also try to model how each adder should behave, given that it's wired up to other adders in this specific order. Let's write a couple of helpers first, and then combine them to describe the behavior of each adder, given its place in the sequence.</p>
<h3 id="when-is-an-adders-output-bit-set-to-true"><a class="header" href="#when-is-an-adders-output-bit-set-to-true">When is an adder's output bit set to true?</a></h3>
<p>Just like <code>pred</code>icates can be used as boolean-valued helpers, <code>fun</code>ctions can act as helpers for arbitrary return types. Let's try to write one that says what the <em>output</em> bit should be for a specific full adder, given its input bits. </p>
<pre><code class="language-forge">// Helper function: what is the output sum bit for this full adder?
fun adder_S_RCA[f: one FullAdder]: one Digit  {
  // Our job is to fill this in with an expression for the output sum bit
} 
</code></pre>
<p>Looking at the table above, the adder's output value is true if and only if an odd number of its 3 inputs is true. That gives us 4 combinations:</p>
<ul>
<li><code>A</code>, <code>B</code>, and <code>CIN</code> (all 3 are true);</li>
<li><code>A</code> only (1 is true); </li>
<li><code>B</code> only (1 is true); or</li>
<li><code>CIN</code> only (1 is true). </li>
</ul>
<p>This is where we need to remember that the sig <code>T</code> is not a Forge formula yet; to make it into one, we need to explicitly test whether each value is equal to <code>T</code>. We'll use two new Forge constructs to write the function body:</p>
<ul>
<li>The <code>let</code> construct makes it easier to write the value for each of these wires. A <code>let</code> looks similar to a quantifier, but it only introduces some local helper syntax. If I write <code>let A = (f.a_in = T) | ...</code>, I can then use <code>A</code> in place of the tedious <code>(f.a_in = T)</code>. </li>
<li>Expression if-then-else lets us produce a value based on a condition, sort of like the <code>C ? X : Y</code> operator in languages like JavaScript. If I write something like <code>(A and B and C) =&gt; T else F</code> this evaluates to <code>T</code> whenever <code>A</code>, <code>B</code>, and <code>C</code> are all true, and <code>F</code> otherwise.</li>
</ul>
<p>Now we can write:</p>
<pre><code class="language-forge">// Helper function: what is the output bit for this full adder?
fun adder_S_RCA[f: one FullAdder]: one Digit  {
  // &quot;T&quot; and &quot;F&quot; are values, we cannot use them as Forge formulas. 
  let A = (f.a_in = T), B = (f.b_in = T), CIN = (f.carry_in = T) |
   -- Expression if-then-else: if any of these conditions holds...
	 ((     A  and      B  and      CIN)  or 
    (     A  and (not B) and (not CIN)) or 
    ((not A) and      B  and (not CIN)) or 
    ((not A) and (not B) and      CIN))
      -- ...then T...
	 	  =&gt;   T
      -- ...otherwise F.
      else F
} 
</code></pre>
<div id="admonition-couldnt-we-have-just-used-a-pred-here" class="admonition admonish-tip">
<div class="admonition-title">
<p>Couldn't we have just used a <code>pred</code> here?</p>
<p><a class="admonition-anchor-link" href="#admonition-couldnt-we-have-just-used-a-pred-here"></a></p>
</div>
<div>
<p>It might be a bit strange to write a helper function that returns a <code>Digit</code>, rather than a predicate directly. We could make a <code>pred</code> work, but we'd still have to eventually use <code>T</code> and <code>F</code> somewhere, since they are the values that the output bits can take on.</p>
</div>
</div>
<div id="admonition-is-the-blank-space-in-that-example-significant" class="admonition admonish-note">
<div class="admonition-title">
<p>Is the blank space in that example significant?</p>
<p><a class="admonition-anchor-link" href="#admonition-is-the-blank-space-in-that-example-significant"></a></p>
</div>
<div>
<p>Nope. I added it for clarity, because it's much harder to read without the extra space to make it apparent where the <code>not</code>s are applied. Likewise, you don't need to wrap a negation in parentheses; I just think <code>(not A)</code> is clearer than <code>not A</code> in this sort of big expression.</p>
</div>
</div>
<div id="admonition-implies-and-expression-if-then-else" class="admonition admonish-tip">
<div class="admonition-title">
<p>Implies and expression if-then-else</p>
<p><a class="admonition-anchor-link" href="#admonition-implies-and-expression-if-then-else"></a></p>
</div>
<div>
<p>You can also write <code>implies</code> as <code>=&gt;</code>. Indeed, the two keywords (<code>=&gt;</code> and <code>implies</code>) are interchangeable in Forge! To avoid confusion, always ask yourself whether you are trying to identify a <em>thing</em> in an instance, like a full-adder atom or an integer, or write a <em>constraint</em> which may or may not be true in an instance.</p>
</div>
</div>
<h3 id="when-is-an-adders-carry-bit-set-to-true"><a class="header" href="#when-is-an-adders-carry-bit-set-to-true">When is an adder's carry bit set to true?</a></h3>
<p>This one is quite similar. The carry bit is set to true if and only if 2 or 3 of the adder's inputs are true:</p>
<ul>
<li><code>B</code> and <code>CIN</code> (2 are true);</li>
<li><code>A</code> and <code>CIN</code> (2 are true); </li>
<li><code>C</code> and <code>CIN</code> (2 are true); or</li>
<li><code>A</code>, <code>B</code>, and <code>CIN</code> (all 3 are true). 
As before, we'll use <code>let</code> and expression if-then-else, and add (decorative) blank space to make the function more readable.</li>
</ul>
<pre><code class="language-forge">// Helper function: what is the output carry bit for this full adder?
fun adder_cout_RCA[f: one FullAdder]: one Digit {
 let A = (f.a_in = T), B = (f.b_in = T), CIN = (f.carry_in = T) |
     (((not A) and      B  and      CIN) or 
      (     A  and (not B) and      CIN) or 
      (     A  and      B  and (not CIN)) or 
      (     A  and      B  and      CIN)) 
	      =&gt;   T
        else F
} 
</code></pre>
<h3 id="adder-behavior"><a class="header" href="#adder-behavior">Adder Behavior</a></h3>
<p>Finally, what ought an adder's behavior to be? Well, we need to specify its output bits in terms of its input bits. We'll also add a constraint that says the full adders are connected in a line. More concretely, if there <em>is</em> a successor, its input carry bit is equal to the current adder's output carry bit. Here's a picture of what we want to say:</p>
<p><strong>TODO: fill picture</strong></p>
<p>And here's the Forge predicate:</p>
<pre><code class="language-forge">pred fullAdderBehavior[f: FullAdder] {
  -- Each full adder's outputs are as expected
  f.sum_out = adder_S_RCA[f]
  f.carry_out = adder_cout_RCA[f]
  -- Full adders are chained appropriately
  (some RCA.nextAdder[f]) implies (RCA.nextAdder[f]).carry_in = f.carry_out 
}
</code></pre>
<div id="admonition-wouldnt-it-be-better-to-put-the-carry-bit-connection-in-wellformed-or-somewhere-else" class="admonition admonish-note">
<div class="admonition-title">
<p>Wouldn't it be better to put the carry-bit connection in <code>wellformed</code>, or somewhere else?</p>
<p><a class="admonition-anchor-link" href="#admonition-wouldnt-it-be-better-to-put-the-carry-bit-connection-in-wellformed-or-somewhere-else"></a></p>
</div>
<div>
<p>That's a good point. The values of <code>f.sum_out</code> and <code>f.carry_out</code> are part of the full adder's behavior, but the way the wires are connected in <code>RCA.nextAdder</code> is not. </p>
<p>If I were going to re-write this model, I would probably move that line into somewhere that is responsible for <em>connecting</em> the adders: perhaps a predicate for the ripple-carry adder. But I haven't done that—hoping to provoke just this question!</p>
<p>The general design principle here is to think about <em>compositionality and reuse</em>: we'd like to be able to use the same predicates to reason about full adders by themselves, or what would happen if we connected them differently. As written, the <code>fullAdderBehavior</code> predicate doesn't allow for that; we'd have to refactor it. But I'll leave that as an exercise for now.</p>
</div>
</div>
<p>Finally, we'll make a predicate that describes the behavior of the overall ripple-carry adder: </p>
<pre><code>// Top-level system specification: compose preds above
pred rca {  
  wellformed
  all f: FullAdder | fullAdderBehavior[f] 
}
</code></pre>
<div id="admonition-notice-what-weve-done" class="admonition admonish-note">
<div class="admonition-title">
<p>Notice what we've done.</p>
<p><a class="admonition-anchor-link" href="#admonition-notice-what-weve-done"></a></p>
</div>
<div>
<p>Here's something to keep in mind for when we start the next chapter. By wiring together full adders into a sequence via the <code>rca</code> predicate, we are now implicitly hinting at time in our model: signal flows through each adder, in order, over time. We'll re-use this same technique in the next chapter to combine different system states into a succession of them that represents a complete run of the system.</p>
</div>
</div>
<p>Now we're ready to write some examples. We'll make a pair of examples for <code>wellformed</code> and an overall example for the full system. In practice, we'd probably want to write a couple of examples for <code>fullAdderBehavior</code> as well, but we'll leave those out for brevity. </p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Always try to write at least some positive <em>and</em> negative examples.</p>
<h3 id="positive-example"><a class="header" href="#positive-example">Positive Example</a></h3>
<pre><code class="language-forge">example twoAddersLinear is {wellformed} for {
  RCA = `RCA0 
  FullAdder = `FullAdder0 + `FullAdder1
  -- Remember the back-tick mark here! These lines say that, e.g., for the atom `RCA0, 
  -- its firstAdder field contains `FullAdder0. And so on.
  `RCA0.firstAdder = `FullAdder0
  `RCA0.nextAdder = `FullAdder0 -&gt; `FullAdder1
}
</code></pre>
<div id="admonition-notice-that-this-example-is-limited" class="admonition admonish-tip">
<div class="admonition-title">
<p>Notice that this example is limited.</p>
<p><a class="admonition-anchor-link" href="#admonition-notice-that-this-example-is-limited"></a></p>
</div>
<div>
<p>Because we are testing <code>wellformed</code>, we left out fields that didn't matter to that predicate. Forge will feel free to adjust them as needed. When a field is left unspecified, the example is said to be <em>partial</em>, and it becomes a check for consistency. E.g., in this case, the example passes because the partial instance given <em>can</em> satisfy <code>wellformed</code>—not that it must satisfy <code>wellformed</code>—although in this case the difference is immaterial because <code>wellformed</code> really doesn't care about any of the other fields.</p>
</div>
</div>
<h3 id="negative-example"><a class="header" href="#negative-example">Negative Example</a></h3>
<pre><code class="language-forge">example twoAddersLoop is {not wellformed} for {
  RCA = `RCA0 
  FullAdder = `FullAdder0 + `FullAdder1
  `RCA0.firstAdder = `FullAdder0
  `RCA0.nextAdder = `FullAdder0 -&gt; `FullAdder1 + `FullAdder1 -&gt; `FullAdder0
}
</code></pre>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>Let's have a look at a ripple-carry adder in action. We'll pick a reasonably small number of bits: 4. </p>
<pre><code class="language-forge">run {rca} for exactly 4 FullAdder
</code></pre>
<p><strong>(FILL: screenshot)</strong></p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Ok, we've looked at some of the model's output, and it seems right. But how can we be really confident that the ripple-carry adder <em>works</em>? Can we use our model to <em>verify</em> the adder? Yes, but we'll need to do a bit more modeling. </p>
<p><strong>Exercise:</strong> What does it mean for the adder to &quot;work&quot;? </p>
<details>
<summary>Think, then click!</summary>
<p>For one thing, it had better produce a series of boolean outputs that correspond to the output we'd get if we just did the addition. That is, if we add together the numbers <code>2</code> (<code>10</code>) and <code>3</code> (<code>11</code>) we should expect to get <code>5</code>—which should be <code>101</code> in binary, provided we always set the bit-width high enough to match the number of bits we're adding together. </p>
<p>Let's augment our model to check this. We'll ask Forge for an instance where the ripple-carry adder produces a different result (taken as the sum of the outputs of each full adder) than the expected (produced via Forge's <code>add</code> function). </p>
</details>
<hr />
<p>When I'm expanding a model in this way, I like to augment instances with extra fields that exist <em>just for verification</em>, and which aren't part of the system we're modeling. Here, we'll keep track of the place-values of each full adder, which we can then use to compute the &quot;true&quot; value of its input or output. E.g., the first full adder would have place-value 1, and its successors would have place-value 2, then 4, etc. </p>
<div id="admonition-helper-values" class="admonition admonish-note">
<div class="admonition-title">
<p>Helper values</p>
<p><a class="admonition-anchor-link" href="#admonition-helper-values"></a></p>
</div>
<div>
<p>Sometimes you'll hear this sort of new field or value referred to as a &quot;ghost&quot;: it isn't real; it doesn't exist in the actual system.</p>
</div>
</div>
<p>We could store this field in the <code>FullAdder</code> sig, but let's keep the original unmodified, and instead add a <code>Helper</code> sig. This keeps the for-verification-only fields separate from the model of the system:</p>
<pre><code class="language-forge">one sig Helper {
  place: func FullAdder -&gt; Int
}
</code></pre>
<p>The ripple-carry adder gives us the context we need to speak of the place value each full adder ought to have. We can write this for the first adder easily:</p>
<pre><code class="language-forge">-- The &quot;places&quot; helper value should agree with the ordering that the RCA establishes.
pred assignPlaces {
  -- The least-significant bit is 2^0
  Helper.place[RCA.firstAdder] = 1
  -- ...
}
</code></pre>
<p>Now we need to, in effect, write a for-loop or a recursive function that constrains <code>places</code> for all the other adders. But Forge has no recursion or loops! Fortunately, it does have the <code>all</code> quantifier, which lets us define every other adder's <code>place</code> value in terms of its predecessor:</p>
<pre><code class="language-forge">-- The &quot;places&quot; helper value should agree with the ordering that the RCA establishes.
pred assignPlaces {
  -- The least-significant bit is 2^0
  Helper.place[RCA.firstAdder] = 1
  -- Other bits are worth 2^(i+1), where the predecessor is worth 2^i.
  all fa: FullAdder | some RCA.nextAdder[fa] =&gt; {    
    Helper.place[RCA.nextAdder[fa]] = multiply[Helper.place[fa], 2]
  }
}
</code></pre>
<p>When you have quantification and helper fields, you can often avoid needing real iteration or recursion.</p>
<p>We'll add a helper function for convenience later:</p>
<pre><code class="language-forge">fun actualValue[b: Digit, placeValue: Int]: one Int {
  (b = T) =&gt; placeValue else 0
}
</code></pre>
<h3 id="the-requirement"><a class="header" href="#the-requirement">The Requirement</a></h3>
<p>Let's try to express our requirement that the adder is correct. Again, we'll phrase this as: for every full adder, the true value of its output is the sum of the true values of its inputs (where &quot;true value&quot; means the value of the boolean, taking into account its position). We might produce something like this:</p>
<pre><code class="language-forge">pred req_adderCorrect_wrong {
  (rca and assignPlaces) implies {
    all fa: FullAdder | { 
        actualValue[fa.sum_out, Helper.place[fa]] = add[actualValue[fa.a_in, Helper.place[fa]], 
                                                  actualValue[fa.b_in, Helper.place[fa]]]
    }
  }
}
</code></pre>
<p>And then we'll use it in a test. It's vital that we have a high-enough bitwidth, so that Forge can count up to the actual expected result, without overflowing. Forge <code>int</code>s are signed, so we actually need a bigger bit-width than the number of full adders. If we have, say, 6 full adders, we might end up producing a 7-bit output (with carrying). A 7-bit value can conservatively hold up to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span>. To count up to that high, we need to use <em>8</em> bits in Forge, giving the solver all the numbers between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">128</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span>, inclusive.</p>
<div id="admonition-directly-testing-satisfiability" class="admonition admonish-tip">
<div class="admonition-title">
<p>Directly testing satisfiability</p>
<p><a class="admonition-anchor-link" href="#admonition-directly-testing-satisfiability"></a></p>
</div>
<div>
<p>So far, we've only seen <code>example</code>s and <code>assert</code>ions. Both of these are built using Forge's basic satisfiability checking. We can access this directly using the <code>test expect</code> feature. You can write that a run:</p>
<ul>
<li>should have instances (i.e., be satisfiable): <code>is sat</code>;</li>
<li>should not have instances (i.e., be unsatisfiable, within the bounds given): <code>is unsat</code>; or</li>
<li>should have no counterexample instances (within the bounds given): <code>is theorem</code>.</li>
</ul>
</div>
</div>
<pre><code class="language-forge">-- Ask Forge to check the satisfiability of something...
test expect {  
  -- Is it _always_ true, up to these bounds, that `req_adderCorrect` always holds?
  r_adderCorrect: {req_adderCorrect} for 6 FullAdder, 1 RCA, 8 Int is theorem
}
</code></pre>
<p>However, this requirement fails—Forge finds a counterexample. </p>
<p><strong>Exercise:</strong> What's wrong? Is the adder broken, or might our property be stated incorrectly?</p>
<details>
<summary>Think, then click!</summary>
<p>We forgot to take carrying into account! Any time a full adder carries a bit, it's dropped by the left-hand side of the above equation. </p>
<p>Notice how even if the model (or system) is correct, sometimes the property itself is wrong. Always be skeptical about your properties, just like you're skeptical about your model.</p>
</details>
<hr />
<p>Here's another attempt:</p>
<pre><code class="language-forge">pred req_adderCorrect {
  (rca and assignPlaces) implies {
    all fa: FullAdder | { 
        -- Include carrying, both for input and output. The _total_ output's true value is equal to
        -- the the sum of the total input's true value.

        -- output value bit + output carry bits; note carry value is *2 (and there may not be a &quot;next adder&quot;)
        add[actualValue[fa.sum_out, Helper.place[fa]], 
            multiply[actualValue[fa.carry_out, Helper.place[fa]], 2]] 
        = 
        -- input a bit + input b bit + input carry bit
        add[actualValue[fa.a_in, Helper.place[fa]],     
            actualValue[fa.b_in, Helper.place[fa]],    
            actualValue[fa.carry_in, Helper.place[fa]]]  
    }
  }
}
</code></pre>
<p>Now when we run the check, it passes. There's just one problem—it only passes <em>eventually</em>. The verification step took over a minute on my laptop! That's rather slow for a model this size. </p>
<h3 id="optimizing-verification"><a class="header" href="#optimizing-verification">Optimizing Verification</a></h3>
<p>When this sort of unexpected slowdown happens, it's often because we've given the solver too much freedom, causing it to explore a much larger search space than it should have to. This is especially pronounced when we expect an &quot;unsatisfiable&quot; result—then, the solver really does need to explore <em>everything</em> before concluding that no, there are no solutions. We're in that situation here, since we're hoping there are no counter-examples to correctness. </p>
<p><strong>Exercise:</strong> What did we leave the solver to figure out on its own, that we maybe could give it some help with?</p>
<details>
<summary>Think, then click!</summary>
<p>There are at least two things. </p>
<ul>
<li>First, the exact ordering of full adders isn't something we provided. We just said &quot;create up to 6 of them, and wire them together in a line&quot;. Considering just the 6-adder case (and not the 5-adder case, 4-adder case, etc.), how many ways are there to arrange the adders? <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">6</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">720</span></span></span></span>. Unless the solver can detect and eliminate these symmetries, it's doing a <em>lot</em> more work than it needs to. </li>
<li>Second, we said that <code>Helper.place</code> mapped full adders to integers. But does the solver need to consider <em>all</em> integers? No! Just <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, and so on. The vast majority of integers in the scope we provided cannot be used—and the solver will have to discover that on its own.</li>
</ul>
</details>
<hr />
<p>These both present opportunities for optimization! For now, let's just tackle the first one: we need to somehow give Forge a specific ordering on the adders, rather than letting the solver explore all possible orderings. E.g., maybe we want a series of atoms <code>FullAdder0</code>, <code>FullAdder1</code>, ..., <code>FullAdder5</code>, which ordering <code>RCA.nextAdder</code> respects. </p>
<p>We could try to express this as a constraint: </p>
<pre><code class="language-forge">pred orderingOnAdders {
  some disj fa0, fa1, fa2, fa3, fa4, fa5: FullAdder | {
    RCA.firstAdder = fa0
    RCA.nextAdder[fa0] = fa1 
    RCA.nextAdder[fa1] = fa2
    RCA.nextAdder[fa2] = fa3 
    RCA.nextAdder[fa3] = fa4 
    RCA.nextAdder[fa4] = fa5 
  }
}
</code></pre>
<p>However, this won't be very effective. </p>
<p><strong>Exercise:</strong> Why won't adding <code>orderingOnAdders</code> to our set of constraints actually help much, if at all? </p>
<details>
<summary>Think, then click!</summary>
<p>Because all of that is already implied by the other constraints we have. It's true that sometimes rephrasing a constraint like this can have a big impact on performance if the solver can figure out how to use it well, but in this case the problem is one of symmetries; the solver would <em>just keep checking all possibilities</em> for the <code>fa0</code>, <code>fa1</code>, etc. variables anyway. </p>
<p>Fortunately, there's a much better option. </p>
</details>
<hr />
<p>Recall that Forge works by searching for satisfying instances within some large possibility space, and that this space is restricted by the bounds given. The search process is run by a sophisticated solver, but the problem that the solver itself gets looks nothing like Forge. The process of solving a Forge problem thus has three separate stages: </p>
<ul>
<li>express the solution space in a form the solver understands, which is usually a large set of boolean variables; </li>
<li>convert the constraints into a form the solver understands, which needs to be in terms of the converted solution-space variables; and only then</li>
<li>invoke the solver on the converted problem.</li>
</ul>
<p>Adding constraints will affect the later steps, but we'd love to give hints to the translator even earlier in the process. We'll talk more about exactly how this works later, but for now, we'll add a <em>bounds annotation</em> to our run: that the <code>nextAdder</code> field is <em>partial-linear</em>, or <code>nextAdder is plinear</code>. Linearity means that the atoms which <code>nextAdder</code> maps should be pre-arranged in a fixed order before they get to the solver at all. Partial linearity means that the ordering may not use all of the potential atoms. </p>
<pre><code class="language-forge">test expect {  
  r_adderCorrect: {req_adderCorrect} for 6 FullAdder, 1 RCA, 8 Int for {nextAdder is plinear} is theorem
}
</code></pre>
<p>This wasn't hard to add: it's just another <code>{}</code>-delimited instruction that you can add to any <code>run</code>, <code>test</code>, etc. command. Now Forge finishes the check in under a second on my laptop. Eliminating symmetries can make a huge difference! </p>
<div id="admonition-bounds-vs-constraints" class="admonition admonish-warning">
<div class="admonition-title">
<p>Bounds vs. Constraints</p>
<p><a class="admonition-anchor-link" href="#admonition-bounds-vs-constraints"></a></p>
</div>
<div>
<p>Notice that the bounds annotation is grouped after the numeric bounds, <em>not</em> with the constraints. This is because the two are separate. If we had tried to put <code>nextAdder is plinear</code> in as a constraint in our predicate, we would have gotten an error, because Forge doesn't know how to interpret it as a constraint, only how to use it to shape the solution space passed to the solver.</p>
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../chapters/bst/bst.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../chapters/qna/static.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../chapters/bst/bst.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../chapters/qna/static.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
